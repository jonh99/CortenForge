<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>CortenForge Contributor Guide</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="architecture.html"><strong aria-hidden="true">1.2.</strong> Architecture</a></li></ol></li><li class="chapter-item expanded "><a href="core_crates.html"><strong aria-hidden="true">2.</strong> Core crates</a></li><li class="chapter-item expanded "><a href="hooks.html"><strong aria-hidden="true">3.</strong> Hooks / extension points</a></li><li class="chapter-item expanded "><a href="publishing.html"><strong aria-hidden="true">4.</strong> Publishing crates</a></li><li class="chapter-item expanded "><a href="apps_index.html"><strong aria-hidden="true">5.</strong> Apps</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="apps.html"><strong aria-hidden="true">5.1.</strong> App patterns</a></li></ol></li><li class="chapter-item expanded "><a href="tools.html"><strong aria-hidden="true">6.</strong> Tools crate</a></li><li class="chapter-item expanded "><a href="testing.html"><strong aria-hidden="true">7.</strong> Testing</a></li><li class="chapter-item expanded "><a href="ci.html"><strong aria-hidden="true">8.</strong> CI</a></li><li class="chapter-item expanded "><a href="roadmap.html"><strong aria-hidden="true">9.</strong> Roadmap</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="migration.html"><strong aria-hidden="true">9.1.</strong> Migration / roadmap</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">CortenForge Contributor Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>Welcome to the contributor guide for CortenForge. This book explains how the substrate and example apps fit together, what design choices were made, and how to extend or modify the system without getting lost.</p>
<h2 id="what-this-is"><a class="header" href="#what-this-is">What this is</a></h2>
<ul>
<li>A modular simulation substrate (CortenForge) plus example apps (<code>colon_sim</code> reference, <code>hello_substrate</code> minimal).</li>
<li>Shared crates for runtime orchestration, capture/inference, ETL, training, and tooling.</li>
<li>A map for contributors: where code lives, how pieces talk, and how to add or change behavior safely.</li>
</ul>
<h2 id="who-should-read-this"><a class="header" href="#who-should-read-this">Who should read this</a></h2>
<ul>
<li>New contributors ramping up on architecture and conventions.</li>
<li>Engineers adding features (runtime hooks, vision/capture, recorder sinks, tools).</li>
<li>Domain authors building a new app on the substrate or adapting the reference app.</li>
</ul>
<h2 id="how-to-use-this-book"><a class="header" href="#how-to-use-this-book">How to use this book</a></h2>
<ul>
<li>Start with <strong>Introduction</strong> for scope and expectations.</li>
<li>Read <strong>Architecture</strong> for the substrate vs. app split and the runtime/data flow.</li>
<li>Jump to the chapter that matches your work:
<ul>
<li><strong>Core crates</strong> if you’re inside shared runtime/vision/recorder code.</li>
<li><strong>Hooks / extension points</strong> when wiring new behavior into the sim loop or recorder.</li>
<li><strong>Apps</strong> for patterns and the reference app tour.</li>
<li><strong>Tools crate</strong> for CLI utilities and adding new commands.</li>
<li><strong>Testing</strong> / <strong>CI</strong> for validation and pipelines.</li>
<li><strong>Roadmap</strong> for upcoming changes and migration notes.</li>
</ul>
</li>
</ul>
<h2 id="scope"><a class="header" href="#scope">Scope</a></h2>
<ul>
<li>In scope: architecture, crate responsibilities, extension points, app wiring, tools, testing/CI, and migration guidance.</li>
<li>Out of scope: end-user gameplay instructions (see user book), hardware/patent licensing specifics (see <code>COMMERCIAL_LICENSE.md</code>), and exhaustive API docs (read the code; this book points you there).</li>
</ul>
<h2 id="repo-map-at-a-glance"><a class="header" href="#repo-map-at-a-glance">Repo map (at a glance)</a></h2>
<ul>
<li><code>src/</code>: CLI + orchestrator (<code>run_app</code>), no domain systems.</li>
<li><code>sim_core/</code>, <code>vision_core/</code>, <code>vision_runtime/</code>, <code>data_contracts/</code>, <code>capture_utils/</code>, <code>models/</code>, <code>training/</code>, <code>inference/</code>, <code>tools/</code>: substrate crates.</li>
<li><code>apps/colon_sim/</code>, <code>apps/hello_substrate/</code>: example apps.</li>
<li><code>docs/user_book/</code>, <code>docs/contributor_book/</code>: mdBooks (run <code>mdbook build docs/contributor_book</code>).</li>
</ul>
<h2 id="conventions"><a class="header" href="#conventions">Conventions</a></h2>
<ul>
<li>Keep core crates domain-agnostic and detector-free; apps supply domain systems and sinks.</li>
<li>Favor small, composable surfaces (SimHooks, recorder meta/world state, vision hooks).</li>
<li>Prefer defaults and clear wiring over deep abstraction; gate heavy deps behind features.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This book is for contributors to the CortenForge substrate and its example apps. It explains how the pieces fit, why the architecture looks the way it does, and how to extend the system safely.</p>
<p>What to expect:</p>
<ul>
<li>Architecture and data flow: substrate vs. apps, runtime wiring, capture/inference/ETL/training loop.</li>
<li>Core crates: responsibilities and boundaries.</li>
<li>Hooks / extension points: where to plug in controls, autopilot, recorder meta/world state, and vision capture/inference hooks.</li>
<li>Apps: patterns, reference app tour (<code>colon_sim</code>), and how to build your own.</li>
<li>Tooling: CLI utilities, adding new tools, feature flags.</li>
<li>Testing and CI: what to run, backends, fixtures, and how pipelines are structured.</li>
<li>Roadmap and migration notes: upcoming changes, version bumps, deprecations.</li>
</ul>
<p>Housekeeping:</p>
<ul>
<li>Build this book: <code>mdbook build docs/contributor_book</code></li>
<li>Build the user book (end-user flows): <code>mdbook build docs/user_book</code></li>
<li>Recent refactor highlights: see <code>MIGRATION.md</code> (root orchestrator, app crates under <code>apps/</code>, tools split, recorder defaults, tests/docs refresh).</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-substrate--apps"><a class="header" href="#architecture-substrate--apps">Architecture: substrate + apps</a></h1>
<p>How CortenForge is structured, how data and control flow through it, and where apps attach.</p>
<h2 id="big-picture"><a class="header" href="#big-picture">Big picture</a></h2>
<ul>
<li><strong>Substrate crates</strong>: <code>sim_core</code> (Bevy scaffolding, mode sets, hooks, recorder types), <code>vision_core</code> (detector interfaces + overlay math), <code>vision_runtime</code> (capture/inference plugins), <code>data_contracts</code> (schemas), <code>capture_utils</code> (sinks/overlay/prune), <code>models</code> (TinyDet/BigDet), <code>training</code>, <code>inference</code>, <code>colon_sim_tools</code>.</li>
<li><strong>Apps</strong>: <code>apps/colon_sim</code> (reference world) and <code>apps/hello_substrate</code> (minimal demo). Apps supply domain systems; substrate stays detector- and domain-agnostic.</li>
<li><strong>Root crate</strong>: glue only (<code>src/cli/*</code>, <code>run_app</code>), wires <code>SimConfig</code> + plugins + app hooks.</li>
</ul>
<h2 id="runtime-flow-per-run"><a class="header" href="#runtime-flow-per-run">Runtime flow (per run)</a></h2>
<ol>
<li>CLI parses <code>AppArgs</code> → choose <code>RunMode</code> (Sim/Datagen/Inference) → call <code>run_app</code>.</li>
<li>Build base Bevy app via <code>sim_core::build_app</code> + <code>SimPlugin</code> (mode sets/config) + <code>SimRuntimePlugin</code> (runtime systems).</li>
<li>Add <code>vision_runtime</code> plugins:
<ul>
<li><code>CapturePlugin</code> (image target/readback setup, camera tracking, capture loop).</li>
<li><code>InferencePlugin</code> (optional; schedules detector on captured frames).</li>
</ul>
</li>
<li>Add app plugins/systems (controls/autopilot/HUD/world, recorder world state).</li>
<li>Recorder (in <code>sim_core</code>) runs with default <code>JsonRecorder</code>; app provides metadata/world state and can inject sinks.</li>
<li>Run Bevy app; mode sets gate systems (Common/SimDatagen/Inference).</li>
</ol>
<h2 id="data-flow-happy-path"><a class="header" href="#data-flow-happy-path">Data flow (happy path)</a></h2>
<ul>
<li><strong>Capture</strong> (<code>sim_view</code> interactive or <code>datagen</code> headless) → writes <code>run_&lt;ts&gt;</code> dirs under <code>assets/datasets/captures/</code> with frames, labels, overlays (optional), manifest.</li>
<li><strong>Prune/overlay</strong> (tools via <code>capture_utils</code>) → optional <code>captures_filtered/</code> and overlays.</li>
<li><strong>ETL</strong> (<code>warehouse_etl</code>) → tensor warehouse shards + manifest under <code>artifacts/tensor_warehouse/v&lt;ts&gt;/</code>.</li>
<li><strong>Training</strong> consumes warehouse manifest → checkpoints in <code>checkpoints/</code> (TinyDet/BigDet).</li>
<li><strong>Inference</strong> (live via <code>inference_view</code> or single-image) loads checkpoint; falls back to heuristic detector if none provided.</li>
</ul>
<h2 id="call-graph-high-level"><a class="header" href="#call-graph-high-level">Call graph (high level)</a></h2>
<ul>
<li><code>run_app</code> → <code>sim_core::build_app</code> → add <code>SimPlugin</code>/<code>SimRuntimePlugin</code> → add <code>vision_runtime</code> capture (+ inference when requested) → add app plugins (<code>AppSystemsPlugin</code>, <code>AppBootstrapPlugin</code>, etc.) → <code>App::run</code>.</li>
<li>Recorder pipeline: app injects <code>RecorderMetaProvider</code> + <code>RecorderWorldState</code> updates; substrate installs default sink; frames/labels flow to disk; tools/ETL read manifests.</li>
</ul>
<h2 id="design-principles"><a class="header" href="#design-principles">Design principles</a></h2>
<ul>
<li>Keep substrate detector-free and domain-agnostic; apps own world/systems.</li>
<li>Small, explicit surfaces: SimHooks, recorder meta/world state, vision hooks; avoid sprawling abstraction layers.</li>
<li>Defaults first; feature-gate heavy deps; NdArray backend for tests.</li>
<li>Make wiring obvious (plugins, sets, resources), favor clarity over indirection.</li>
</ul>
<h2 id="repository-map-at-a-glance"><a class="header" href="#repository-map-at-a-glance">Repository map (at a glance)</a></h2>
<pre><code>src/              # glue: cli, run_app (orchestration only)
apps/colon_sim/   # reference app (world, HUD, autopilot, bins)
apps/hello_substrate/ # minimal demo app
sim_core/         # Bevy plumbing + hooks + recorder types
vision_core/      # detector interfaces + overlay math
vision_runtime/   # capture/inference plugins for Bevy
data_contracts/   # schemas + validation
capture_utils/    # recorder sinks + overlay/prune helpers
models/           # TinyDet/BigDet definitions
training/         # training CLI + dataset/loss
inference/        # detector factory (Burn + heuristic)
tools/            # CLI tools (overlay/prune/etl/cmd/scheduler/tui)
docs/user_book/   # user-facing guide
docs/contributor_book/ # contributor guide
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-crates-cortenforge-substrate"><a class="header" href="#core-crates-cortenforge-substrate">Core crates (CortenForge substrate)</a></h1>
<p>What lives in each shared crate, how they interact, and where to extend.</p>
<h2 id="sim_core"><a class="header" href="#sim_core">sim_core</a></h2>
<ul>
<li>Purpose: Bevy scaffolding (app builder, mode sets, config), hooks for controls/autopilot, recorder types. Detector wiring is intentionally absent here.</li>
<li>Key types:
<ul>
<li><code>SimConfig</code> / <code>SimRunMode</code> / <code>ModeSet</code>.</li>
<li><code>SimPlugin</code> (registers config + sets) and <code>SimRuntimePlugin</code> (runtime systems).</li>
<li><code>SimHooks</code>, <code>ControlsHook</code>, <code>AutopilotHook</code> (app-supplied callbacks).</li>
<li>Recorder: <code>RecorderConfig</code>, <code>RecorderState</code>, <code>RecorderMotion</code>, <code>RecorderWorldState</code>, <code>RecorderMetaProvider</code>.</li>
</ul>
</li>
<li>Flow:
<ol>
<li><code>build_app</code> seeds Bevy with DefaultPlugins + Rapier + mode sets.</li>
<li>Apps inject hooks/resources (controls, autopilot, recorder meta/world state).</li>
<li>Recorder sink defaults to JSON (from capture_utils) but can be replaced.</li>
</ol>
</li>
<li>Extend: implement hooks in your app crate; add systems to the relevant sets; supply recorder meta/world updates and custom sinks.</li>
</ul>
<h2 id="vision_core"><a class="header" href="#vision_core">vision_core</a></h2>
<ul>
<li>Purpose: detector/capture data model and overlay math; no Bevy dependency.</li>
<li>Key types: <code>Frame</code>, <code>FrameRecord</code>, <code>DetectionResult</code>, <code>Label</code>, <code>Recorder</code>, <code>Detector</code>, <code>CaptureLimit</code>, <code>draw_rect</code>/overlay helpers.</li>
<li>Extend: implement <code>Detector</code>/<code>Recorder</code>; reuse overlay helpers; keep this crate free of engine/runtime concerns.</li>
</ul>
<h2 id="vision_runtime"><a class="header" href="#vision_runtime">vision_runtime</a></h2>
<ul>
<li>Purpose: Bevy plugins for capture and inference built on vision_core.</li>
<li>Capture pipeline:
<ul>
<li><code>CapturePlugin</code> sets up render target + GPU readback resources (<code>FrontCaptureTarget</code>, <code>FrontCaptureReadback</code>, camera tracking).</li>
<li>Systems capture frames → <code>FrameRecord</code> → recorder sink; gated by <code>SimRunMode</code>.</li>
</ul>
</li>
<li>Inference pipeline:
<ul>
<li><code>InferencePlugin</code> holds <code>DetectorHandle</code> (Burn or heuristic), thresholds, overlay state.</li>
<li>Schedules detector tasks on captured frames; updates overlay UI state; gated to inference mode.</li>
</ul>
</li>
<li>Extend: swap detector handle creation (via <code>inference</code> factory), adjust capture target sizing, or add new observers/overlays.</li>
</ul>
<h2 id="data_contracts"><a class="header" href="#data_contracts">data_contracts</a></h2>
<ul>
<li>Purpose: serde/validation schemas for captures, manifests, shards.</li>
<li>Key schemas: run manifest (id, seed, camera, resize/letterbox, frame count, checksum), frame label (bbox_norm/bbox_px/class/metadata), warehouse shard/manifest.</li>
<li>Extend: add fields as needed; keep validation strict (bbox ranges, required fields).</li>
</ul>
<h2 id="capture_utils"><a class="header" href="#capture_utils">capture_utils</a></h2>
<ul>
<li>Purpose: recorder sinks and capture helpers.</li>
<li>Contents: default <code>JsonRecorder</code> sink, overlay and prune helpers used by tools and tests.</li>
<li>Extend: add sinks (e.g., custom DB writer) while preserving schema compatibility for ETL.</li>
</ul>
<h2 id="models"><a class="header" href="#models">models</a></h2>
<ul>
<li>Purpose: Burn model definitions/configs (TinyDet, BigDet).</li>
<li>Extend: add model variants/configs; keep domain logic out.</li>
</ul>
<h2 id="training"><a class="header" href="#training">training</a></h2>
<ul>
<li>Purpose: training/eval CLI and pipeline on top of warehouse manifests.</li>
<li>Contents: dataset loader (manifest → tensors), collate, loss/matching, optimizer/checkpoint I/O; CLI (<code>train.rs</code>, <code>eval.rs</code>) drives <code>run_train</code>.</li>
<li>Extend: new losses, augmentations, schedulers; keep CLI flags in sync.</li>
</ul>
<h2 id="inference"><a class="header" href="#inference">inference</a></h2>
<ul>
<li>Purpose: detector factory that loads checkpoints (via <code>models</code>) and returns a <code>Detector</code> (Burn-backed) or a heuristic fallback when weights are absent.</li>
<li>Extend: add backends or selection logic; keep the interface consistent for runtime/tools.</li>
</ul>
<h2 id="colon_sim_tools"><a class="header" href="#colon_sim_tools">colon_sim_tools</a></h2>
<ul>
<li>Purpose: CLI utilities: overlay/prune, warehouse_etl/export/cmd, single_infer, tui, datagen_scheduler, helper binaries.</li>
<li>Feature flags: <code>tui</code>, <code>scheduler</code>, <code>gpu_nvidia</code> gate heavier deps.</li>
<li>Extend: add bins under <code>tools/src/bin/</code>; reuse shared parsers/services to avoid duplication.</li>
</ul>
<h2 id="cross-crate-interactions-happy-path"><a class="header" href="#cross-crate-interactions-happy-path">Cross-crate interactions (happy path)</a></h2>
<ol>
<li>sim_core builds the app and recorder scaffolding; app injects hooks + recorder meta/world state.</li>
<li>vision_runtime capture turns renders into <code>FrameRecord</code>s; capture_utils writes JSON labels/images to disk.</li>
<li>data_contracts defines the run/label schema; tools/ETL validate against it.</li>
<li>warehouse_etl (tools) + training consume manifests/shards; models define TinyDet/BigDet; inference factory loads checkpoints; vision_runtime runs detectors live.</li>
</ol>
<h2 id="notes-for-contributors"><a class="header" href="#notes-for-contributors">Notes for contributors</a></h2>
<ul>
<li>Keep sim_core and vision_core domain-agnostic and detector-free; domain/world logic lives in apps.</li>
<li>Prefer explicit plugin wiring and mode gating over hidden magic.</li>
<li>Gate heavy deps behind features; default to NdArray where possible for tests.</li>
<li>Preserve schema compatibility (data_contracts) so ETL/training/tools remain stable.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hooks--extension-points"><a class="header" href="#hooks--extension-points">Hooks / extension points</a></h1>
<p>Where apps plug into the substrate without modifying core crates.</p>
<h2 id="sim-hooks-controlsautopilot"><a class="header" href="#sim-hooks-controlsautopilot">Sim hooks (controls/autopilot)</a></h2>
<ul>
<li><code>SimHooks</code> resource holds optional <code>ControlsHook</code> and <code>AutopilotHook</code> trait objects supplied by the app.</li>
<li>Apps implement these traits to register control/autopilot systems and insert them during setup (e.g., in <code>run_app</code>).</li>
<li>Use <code>ModeSet</code>/<code>SimRunMode</code> to gate your systems (e.g., enable autopilot only in datagen).</li>
</ul>
<h2 id="recorder-hooks"><a class="header" href="#recorder-hooks">Recorder hooks</a></h2>
<ul>
<li>Metadata: app provides <code>RecorderMetaProvider</code> (implements <code>RecorderMetadataProvider</code>) to supply run metadata (seed, scene id, etc.).</li>
<li>World state: app updates <code>RecorderWorldState</code> (e.g., head_z, stop flag) each frame.</li>
<li>Sinks: any <code>RecorderSink</code> can be inserted; default JSON sink comes from <code>capture_utils</code>. Apps may add/replace sinks (DB, custom format) but should maintain schema compatibility if ETL/training are reused.</li>
<li>Typical app wiring:
<ul>
<li>Insert <code>RecorderMetaProvider</code> with your metadata.</li>
<li>Add a system to write <code>RecorderWorldState</code>.</li>
<li>(Optional) Insert custom sink(s) implementing <code>RecorderSink</code>.</li>
</ul>
</li>
</ul>
<h2 id="vision--detector-hooks"><a class="header" href="#vision--detector-hooks">Vision / detector hooks</a></h2>
<ul>
<li>Detectors implement <code>vision_core::Detector</code> (Burn-backed or heuristic). The <code>inference</code> crate provides <code>InferenceFactory</code> to load checkpoints; apps can swap in their own factory or detector.</li>
<li><code>vision_runtime::InferencePlugin</code> expects a <code>DetectorHandle</code> resource; apps insert it (and thresholds) when entering inference mode.</li>
<li>Capture target/readback are set up by <code>vision_runtime::CapturePlugin</code>; you can adjust target size or add observers if needed.</li>
</ul>
<h2 id="mode-gating"><a class="header" href="#mode-gating">Mode gating</a></h2>
<ul>
<li>Use <code>SimRunMode</code> and <code>ModeSet</code> to include/exclude systems:
<ul>
<li>Common: runs in all modes.</li>
<li>SimDatagen: sim + datagen.</li>
<li>Inference: inference-only.</li>
</ul>
</li>
<li>Gate heavy systems (detectors, capture) to the appropriate sets to avoid unnecessary work.</li>
</ul>
<h2 id="extending-safely"><a class="header" href="#extending-safely">Extending safely</a></h2>
<ul>
<li>Keep core crates domain-agnostic; put domain types/systems in your app crate.</li>
<li>Favor narrow hooks and explicit plugin wiring over global state.</li>
<li>When adding sinks or detectors, preserve interfaces so downstream tools (ETL/training) continue to work.</li>
</ul>
<h2 id="mini-recipes"><a class="header" href="#mini-recipes">Mini recipes</a></h2>
<ul>
<li>
<p>Recorder meta/world:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>app.insert_resource(RecorderMetaProvider {
    provider: Box::new(MyMeta { seed, scene_id }),
});
app.add_systems(Update, my_world_state_updater.in_set(ModeSet::Common));
<span class="boring">}</span></code></pre></pre>
<p>Then optionally: <code>app.insert_resource(MySink::new(run_dir));</code></p>
</li>
<li>
<p>Inference handle:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let detector = my_factory.build(thresholds, weights_path);
app.insert_resource(DetectorHandle { detector, kind: DetectorKind::Burn });
app.insert_resource(InferenceThresholds { obj_thresh, iou_thresh });
app.add_plugins(InferencePlugin);
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="publishing-crates"><a class="header" href="#publishing-crates">Publishing crates</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apps"><a class="header" href="#apps">Apps</a></h1>
<p>Guidance for building or extending apps on top of the substrate.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="app-patterns"><a class="header" href="#app-patterns">App patterns</a></h1>
<p>How apps sit on the substrate, with a reference tour and a starter template.</p>
<h2 id="reference-app-appscolon_sim-deep-poo"><a class="header" href="#reference-app-appscolon_sim-deep-poo">Reference app: <code>apps/colon_sim</code> (Deep Poo)</a></h2>
<ul>
<li>Domain systems: world/entities, HUD, controls/autopilot, recorder world-state updates.</li>
<li>Bins: <code>sim_view</code>, <code>inference_view</code> under <code>apps/colon_sim/bin</code>, call <code>run_app</code> with plugins/hook resources.</li>
<li>Uses <code>SimHooks</code> to register controls/autopilot; updates <code>RecorderWorldState</code> and meta; relies on default JSON sink.</li>
<li>Good for: seeing a full integration of capture + inference + recorder + UI.</li>
</ul>
<h2 id="minimal-demo-appshello_substrate"><a class="header" href="#minimal-demo-appshello_substrate">Minimal demo: <code>apps/hello_substrate</code></a></h2>
<ul>
<li>Tiny plugin that adds a system to the substrate without domain code.</li>
<li>Good for: a clean starter layout and minimal bin wiring.</li>
</ul>
<h2 id="build-your-own-app"><a class="header" href="#build-your-own-app">Build your own app</a></h2>
<ul>
<li>Create <code>apps/your_app</code> with:
<ul>
<li><code>src/lib.rs</code>: plugins + systems.</li>
<li><code>src/prelude.rs</code>: re-exports for bins/tests.</li>
<li><code>bin/sim_view.rs</code> / <code>bin/inference_view.rs</code>: CLI → <code>run_app</code> (reuse <code>colon_sim::cli</code> if helpful).</li>
</ul>
</li>
<li>Wiring steps:
<ol>
<li>Start from <code>apps/hello_substrate</code> as a template.</li>
<li>Add your world/entities and systems; register controls/autopilot via <code>SimHooks</code>.</li>
<li>Add a system to update <code>RecorderWorldState</code>; provide <code>RecorderMetaProvider</code> if you need custom metadata.</li>
<li>Optionally insert custom recorder sinks (keep schemas compatible with data_contracts).</li>
<li>Include capture (<code>vision_runtime::CapturePlugin</code>) and inference plugins as needed.</li>
<li>Run <code>cargo check --workspace</code>; add a README describing systems/controls.</li>
<li>Add a smoke test or CLI example to ensure the app builds after changes.</li>
</ol>
</li>
<li>Principles:
<ul>
<li>Keep domain logic in the app crate; core crates stay detector- and domain-agnostic.</li>
<li>Use <code>ModeSet</code>/<code>SimRunMode</code> to gate systems (e.g., only inference in inference mode).</li>
</ul>
</li>
</ul>
<h2 id="bin-wiring-example"><a class="header" href="#bin-wiring-example">Bin wiring (example)</a></h2>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let args = AppArgs::parse();
    run_app(args);
}</code></pre></pre>
<ul>
<li><code>run_app</code> (root crate) builds the base app via <code>sim_core::build_app</code>, inserts <code>SimHooks</code>, recorder meta/world, adds <code>vision_runtime</code> plugins, and app plugins.</li>
<li>Bins can be thin: parse args, maybe tweak defaults, then call <code>run_app</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tools-crate"><a class="header" href="#tools-crate">Tools crate</a></h1>
<p>Contributor guide to <code>colon_sim_tools</code>: bins, shared helpers, feature flags, and how to add new commands.</p>
<h2 id="binaries"><a class="header" href="#binaries">Binaries</a></h2>
<ul>
<li>Core:
<ul>
<li><code>overlay_labels</code>: render boxes onto PNGs for a capture run.</li>
<li><code>prune_empty</code>: drop empty-label frames and write a filtered copy.</li>
<li><code>warehouse_etl</code>: build tensor warehouse shards/manifests from captures.</li>
<li><code>warehouse_export</code>: export warehouse data.</li>
<li><code>warehouse_cmd</code>: emit a training command line tailored to backend/shell.</li>
<li><code>single_infer</code>: run inference on a single image and write boxed output.</li>
</ul>
</li>
<li>Feature-gated:
<ul>
<li><code>datagen_scheduler</code> (feature <code>scheduler</code>): schedule headless datagen runs.</li>
<li><code>tui</code> (feature <code>tui</code>): interactive terminal UI.</li>
<li><code>gpu_nvidia</code> (feature <code>gpu_nvidia</code>): NVML support for scheduler.</li>
</ul>
</li>
</ul>
<h2 id="shared-helpers"><a class="header" href="#shared-helpers">Shared helpers</a></h2>
<ul>
<li>Reuse <code>data_contracts</code> and <code>vision_core</code>/<code>capture_utils</code> for overlay/prune/recorder schema.</li>
<li>Common CLI args imported from <code>colon_sim::cli</code>.</li>
<li>Warehouse helpers live in <code>tools/src/services.rs</code> and <code>tools/src/warehouse_commands/</code>; prefer adding helpers there instead of duplicating logic in bins.</li>
</ul>
<h2 id="defaults-and-features"><a class="header" href="#defaults-and-features">Defaults and features</a></h2>
<ul>
<li>Tools default to lean deps; heavy backends are behind features (see above).</li>
<li>WGPU-heavy paths should be feature-gated; default to NdArray where possible for tests.</li>
</ul>
<h2 id="adding-a-tool"><a class="header" href="#adding-a-tool">Adding a tool</a></h2>
<ul>
<li>Place the bin at <code>tools/src/bin/your_tool.rs</code>.</li>
<li>Reuse existing CLI parsers from <code>colon_sim::cli</code> when applicable.</li>
<li>Use <code>capture_utils</code>/<code>vision_core</code> helpers for overlays/prune/labels; keep schemas consistent with <code>data_contracts</code>.</li>
<li>If the tool needs new shared logic, add it to <code>tools/src/services.rs</code> or <code>tools/src/warehouse_commands/</code> and import it.</li>
</ul>
<h2 id="testing-tools"><a class="header" href="#testing-tools">Testing tools</a></h2>
<ul>
<li>Prefer fast, backend-light tests (NdArray); gate GPU/WGPU usage behind features.</li>
<li>Add smoke tests under <code>tools/tests/</code> for new commands; reuse fixtures where possible.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<p>Expectations for contributors: fast-by-default tests, heavier paths gated behind features, and clear smoke coverage.</p>
<h2 id="defaults"><a class="header" href="#defaults">Defaults</a></h2>
<ul>
<li>Primary backend: NdArray for portability and speed.</li>
<li>WGPU/GPU-heavy tests: feature-gated; do not run by default.</li>
<li>Keep runtimes small; avoid large assets in unit tests.</li>
</ul>
<h2 id="coverage-targets"><a class="header" href="#coverage-targets">Coverage targets</a></h2>
<ul>
<li>Recorder sinks (<code>capture_utils</code>): JSON label writes.</li>
<li>Models: TinyDet/BigDet forward-shape and smoke train (NdArray).</li>
<li>Inference factory: heuristic fallback smoke; Burn load path if weights are present (feature-gated if GPU).</li>
<li>Tools: basic CLI smoke for overlay/prune/warehouse_cmd/warehouse_etl/single_infer (minimal args).</li>
</ul>
<h2 id="recommended-commands"><a class="header" href="#recommended-commands">Recommended commands</a></h2>
<ul>
<li>Fast pass: <code>cargo check --workspace</code></li>
<li>Default tests: <code>cargo test --workspace</code></li>
<li>Opt-in sweep: <code>cargo test --workspace --all-features</code> (enables scheduler/tui/gpu_nvidia/burn_wgpu where available)</li>
<li>Manual smokes: run bins with defaults on small inputs (<code>sim_view</code>, <code>warehouse_etl</code>, <code>train</code>, <code>inference_view</code>).</li>
</ul>
<h2 id="adding-tests"><a class="header" href="#adding-tests">Adding tests</a></h2>
<ul>
<li>Prefer synthetic fixtures; avoid touching large datasets.</li>
<li>Gate GPU/WGPU paths behind features; keep NdArray as the default.</li>
<li>Mirror user-facing defaults in CLI tests; minimize required args.</li>
<li>Place tool tests under <code>tools/tests/</code>, app tests under app crates, core tests in their crates.</li>
</ul>
<h2 id="ci-alignment"><a class="header" href="#ci-alignment">CI alignment</a></h2>
<ul>
<li>Default CI should mirror the default matrix (NdArray-only).</li>
<li>Provide an opt-in job/profile for <code>--all-features</code> if runners support GPUs.</li>
<li>Keep flaky/heavy tests out of the default path; document how to run them manually.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ci"><a class="header" href="#ci">CI</a></h1>
<p>What runs in CI, how to mirror it locally, and expectations for contributors. Adjust specifics to your actual pipeline, but keep the split between fast defaults and opt-in heavy jobs.</p>
<h2 id="pipeline-shape-recommended"><a class="header" href="#pipeline-shape-recommended">Pipeline shape (recommended)</a></h2>
<ul>
<li>Fast lane (default, required):
<ul>
<li><code>cargo fmt -- --check</code></li>
<li><code>cargo clippy --workspace --all-targets --all-features -D warnings</code> (or with minimal features if clippy is too heavy; keep consistent)</li>
<li><code>cargo check --workspace</code></li>
<li><code>cargo test --workspace</code> (NdArray/backends only, no GPU requirements)</li>
<li>mdBook lint/build: <code>mdbook test docs/user_book</code> and <code>mdbook test docs/contributor_book</code> (or at least <code>mdbook build</code>)</li>
</ul>
</li>
<li>Opt-in/heavy lane (manual or nightly):
<ul>
<li><code>cargo test --workspace --all-features</code> (scheduler/tui/gpu_nvidia/burn_wgpu)</li>
<li>GPU/WGPU smoke (if runners have GPUs): minimal inference/capture smoke with WGPU backend.</li>
<li>Larger dataset integration (if applicable): behind a feature flag and separate job.</li>
</ul>
</li>
</ul>
<h2 id="local-reproduction"><a class="header" href="#local-reproduction">Local reproduction</a></h2>
<ul>
<li>Fast pass: <code>cargo fmt -- --check &amp;&amp; cargo clippy --workspace --all-targets -D warnings &amp;&amp; cargo test --workspace</code></li>
<li>Docs: <code>mdbook build docs/user_book &amp;&amp; mdbook build docs/contributor_book</code></li>
<li>Full sweep (optional): <code>cargo test --workspace --all-features</code></li>
</ul>
<h2 id="expectations-for-contributors"><a class="header" href="#expectations-for-contributors">Expectations for contributors</a></h2>
<ul>
<li>Keep default tests fast and backend-light; gate heavy/GPU paths behind features.</li>
<li>Ensure fmt/clippy pass with the same flags CI uses.</li>
<li>Document any new feature flags or env vars needed for tests.</li>
<li>Avoid adding flaky or long-running tests to the default lane; move them to the opt-in lane.</li>
</ul>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<ul>
<li>CI-only clippy/fmt failures: match the CI command flags locally.</li>
<li>Feature-related test failures: verify feature flags and backend availability; default to NdArray.</li>
<li>WGPU/GPU issues: ensure the test is feature-gated; skip on non-GPU runners; provide a manual reproduction command.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="roadmap"><a class="header" href="#roadmap">Roadmap</a></h1>
<p>Forward-looking areas to track and improve. Update this as priorities shift.</p>
<h2 id="near-term-priorities-example-placeholders"><a class="header" href="#near-term-priorities-example-placeholders">Near-term priorities (example placeholders)</a></h2>
<ul>
<li>Stabilize Bevy/WGPU bump plan (0.17 → next) and verify capture/inference.</li>
<li>Harden recorder extensibility: documented sink interface, sample custom sink.</li>
<li>Tooling UX: simplify warehouse_cmd, improve overlay/prune ergonomics.</li>
<li>Docs: finish contributor book chapters; keep user book in sync after renames.</li>
</ul>
<h2 id="medium-term-example-placeholders"><a class="header" href="#medium-term-example-placeholders">Medium-term (example placeholders)</a></h2>
<ul>
<li>Model work: additional detector variants/configs; quantization/export guidance.</li>
<li>Training: more schedulers/augmentations; benchmark harness.</li>
<li>Inference: backend selection UX; performance profiling docs.</li>
<li>CI: optional GPU lane for WGPU smoke; artifact caching for ETL/train tests.</li>
</ul>
<h2 id="longer-term-example-placeholders"><a class="header" href="#longer-term-example-placeholders">Longer-term (example placeholders)</a></h2>
<ul>
<li>Multi-app stories: clearer templates and scaffolding for new domains.</li>
<li>Pluggable data sinks (DB/object store) with schema compatibility guarantees.</li>
<li>Telemetry/observability hooks for runtime.</li>
</ul>
<p>Keep this list short and actionable; link to issues/PRs when concrete.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="migration"><a class="header" href="#migration">Migration</a></h1>
<p>Guidance for moving code/features into the current layout and branding.</p>
<h2 id="refactor-snapshot"><a class="header" href="#refactor-snapshot">Refactor snapshot</a></h2>
<ul>
<li>Root crate is orchestration-only (<code>src/cli/*</code>, <code>run_app</code>); domain systems live in app crates under <code>apps/</code>.</li>
<li>Core crates are domain-agnostic (sim_core, vision_core/runtime, data_contracts, capture_utils, models, training, inference).</li>
<li>Tools live in <code>colon_sim_tools</code>; bins reuse shared helpers via <code>colon_sim::cli</code> and <code>colon_sim_tools::services</code>.</li>
<li>Recorder defaults to <code>JsonRecorder</code>; apps supply metadata/world-state hooks and can inject sinks.</li>
<li>Reference app bins live under <code>apps/colon_sim/bin</code>; minimal demo at <code>apps/hello_substrate</code>.</li>
<li>Branding: substrate is “CortenForge”; app crates consume it.</li>
<li>See <code>MIGRATION.md</code> at repo root for detailed steps and notes.</li>
</ul>
<h2 id="porting-a-feature-to-the-new-layout"><a class="header" href="#porting-a-feature-to-the-new-layout">Porting a feature to the new layout</a></h2>
<ol>
<li>Decide if it belongs in substrate (generic) or app (domain-specific).</li>
<li>If generic, add hooks/helpers to core crates; gate heavy deps with features.</li>
<li>If app-only, put code under <code>apps/your_app/src</code> and register via hooks/plugins.</li>
<li>Update docs (user/contributor) and add a smoke test (NdArray) if applicable.</li>
</ol>
<h2 id="pr-checklist"><a class="header" href="#pr-checklist">PR checklist</a></h2>
<ul>
<li>Docs updated (user and/or contributor book).</li>
<li>Defaults and CLI examples verified.</li>
<li>Tests: <code>cargo check --workspace</code>; add feature-gated tests if new features introduced.</li>
</ul>
<h2 id="adding-a-new-app"><a class="header" href="#adding-a-new-app">Adding a new app</a></h2>
<ul>
<li>Start from <code>apps/hello_substrate</code> layout; wire hooks; add bins; add a short README and a smoke test.</li>
</ul>
<h2 id="extending-tools"><a class="header" href="#extending-tools">Extending tools</a></h2>
<ul>
<li>Put helpers in <code>tools/src/services.rs</code> or <code>tools/src/warehouse_commands/</code>; keep bins thin; gate heavy deps with features.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
